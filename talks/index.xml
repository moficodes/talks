<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Talks</title><link>https://speaking.moficodes.dev/talks/</link><description>Recent content on Talks</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Fri, 01 Mar 2024 12:33:22 -0400</lastBuildDate><atom:link href="https://speaking.moficodes.dev/talks/index.xml" rel="self" type="application/rss+xml"/><item><title>Navigating the Processing Unit Landscape in Kubernetes for AI Use Cases</title><link>https://speaking.moficodes.dev/talks/navigating-proecessing-unit/</link><pubDate>Fri, 01 Mar 2024 12:33:22 -0400</pubDate><guid>https://speaking.moficodes.dev/talks/navigating-proecessing-unit/</guid><description>&lt;h2 id="pitch">Pitch&lt;/h2>
&lt;p>Explain the difference between CPU, GPU and TPU for running LLM and ML workloads. Why people should choose one over the other and where it makes sense to use which one.&lt;/p>
&lt;h2 id="description">Description&lt;/h2>
&lt;p>With the emergence of LLMs (Large Language Models) and other Machine Learning (ML) workloads running on Kubernetes, gone are the days when just CPU is enough. Machine Learning and Artificial Intelligence workloads are best served by specialized processing units. While CPUs are great at doing work sequentially, Artificial Intelligence and Machine Learning require a different approach to processing information - a highly parallel one. In Kubernetes, that means GPUs (Graphical Processing Units) and TPUs (Tensor Processing Units). This talk gives you an introduction of what each type of processing unit is, what they are good at, and how to use them well in Kubernetes.&lt;/p></description></item><item><title>State of Kubernetes Obserbability</title><link>https://speaking.moficodes.dev/talks/state-of-kubernetes-observability/</link><pubDate>Wed, 01 Mar 2023 12:33:22 -0400</pubDate><guid>https://speaking.moficodes.dev/talks/state-of-kubernetes-observability/</guid><description>&lt;h2 id="pitch">Pitch&lt;/h2>
&lt;p>Kubernetes is a complex system with many moving parts. Observability is supposed to give you the insights you need to make this easier. But one quick visit to the CNCF landscape can overwhelm you with the sheer number of tools that exist in the observability space. This talk we will try to distill observability to its core parts and give you the cliffnotes on what you need to know to “know” your Kubernetes workload.
Abstract&lt;/p></description></item><item><title>Go Channels Demystified</title><link>https://speaking.moficodes.dev/talks/go-channels-demystified/</link><pubDate>Wed, 01 Dec 2021 12:45:04 -0400</pubDate><guid>https://speaking.moficodes.dev/talks/go-channels-demystified/</guid><description>&lt;h2 id="pitch">Pitch&lt;/h2>
&lt;p>Go makes concurrency a breeze. But with concurrency comes the trouble of managing info between multiple concurrent process. Thats where channels come in. But do we know all channels has to offer? How can we make better use of this language construct? This is what this talk is about.&lt;/p>
&lt;h2 id="description">Description&lt;/h2>
&lt;p>We are in the era of fast computing. Single threaded programs are often incapable of handling workloads for a modern program. But multithreaded programming is not easy. Go made it easy to use concurrency by making concurrency a part of original language construct. But still some problems remain. Like how do concurrent processes talk to each other? Thats where channels come into play.&lt;/p></description></item><item><title>E2e Ml Platform on K8s</title><link>https://speaking.moficodes.dev/talks/e2e-ml-platform-on-k8s/</link><pubDate>Thu, 01 Apr 2021 12:33:22 -0400</pubDate><guid>https://speaking.moficodes.dev/talks/e2e-ml-platform-on-k8s/</guid><description>&lt;h2 id="pitch">Pitch&lt;/h2>
&lt;p>ML is becoming a core part of our development lifecycle. As such the DevOps days of tomorrow will need to manage these ML platforms. Kubeflow is an open source solution for ML platform. In this talk I will share how to get an E2E ML platform setup using Kubeflow and DevOps practices&lt;/p>
&lt;h2 id="description">Description&lt;/h2>
&lt;p>Kubeflow is a machine learning toolkit for Kubernetes where users can develop, deploy, and manage ML workflows in a scalable and portable manner. Deploying and maintaining it can be a bit tricky since Kubeflow is composed of many components such as notebooks and pipelines and their potential configurations. This makes the barrier to entry to Kubeflow very high and make it difficult for teams to adopt Kubeflow.To help alleviate some of these deployment woes the Kubernetes Kubeflow Operator was created. It automates the deployment, monitoring, and management of Kubeflow as a whole. In this session, users will learn how they can best leverage the Kubeflow Operator to quickly get Kubeflow up and running on their Kubernetes clusters.&lt;/p></description></item><item><title>How We Accidentally Created Cloud on Our Cloud</title><link>https://speaking.moficodes.dev/talks/how-we-accidentally-created-cloud-on-our-cloud/</link><pubDate>Fri, 12 Feb 2021 12:45:58 -0400</pubDate><guid>https://speaking.moficodes.dev/talks/how-we-accidentally-created-cloud-on-our-cloud/</guid><description>&lt;h2 id="pitch">Pitch&lt;/h2>
&lt;p>In an effort to automate tasks for our users we ended up creating a cloud (kind of). In this talk we will describe our journey towards automation, and how we accidentally created a Cloud on our Cloud and why we chose go to do it all.&lt;/p>
&lt;h2 id="description">Description&lt;/h2>
&lt;p>Part of the job of a Developer Advocate is the ability to demo or show off portions of your technology stack to possible users. At IBM we run many workshops and tech demos every week for our clients and conferences. We need to create, monitor, maintain and clean these assets. In this talk we will describe our automation journey from bash scripts run and maintained by individual developers to automating the creations and deletion on automatic schedule with a UI. We will discuss situation, our iterations on what we tried and the painful portions of them, and how we accidentally created a Cloud interface on top of the IBM Cloud, or easier said, we created a Cloud on our Cloud.&lt;/p></description></item><item><title>You Probably Dont Need K8s</title><link>https://speaking.moficodes.dev/talks/you-probably-dont-need-k8s/</link><pubDate>Mon, 11 May 2020 12:52:33 -0400</pubDate><guid>https://speaking.moficodes.dev/talks/you-probably-dont-need-k8s/</guid><description>&lt;h2 id="pitch">Pitch&lt;/h2>
&lt;p>Kubernetes is all the rage these days. You drank the cloud native Kool-aid now you got a fever and the only prescription is more Kubernetes. But is it? Let’s talk about all the reasons why you probably don’t need Kubernetes.&lt;/p>
&lt;h2 id="description">Description&lt;/h2>
&lt;p>Kubernetes is a great piece of technology. It is probably the de-facto container orchestrator for most people using container orchestrators. There is a huge demand for it as well as a lot of interest from businesses to move to Kubernetes.&lt;/p></description></item><item><title>From App Idea to K8s</title><link>https://speaking.moficodes.dev/talks/from-app-idea-to-k8s/</link><pubDate>Fri, 27 Mar 2020 12:34:21 -0400</pubDate><guid>https://speaking.moficodes.dev/talks/from-app-idea-to-k8s/</guid><description>&lt;h2 id="pitch">Pitch&lt;/h2>
&lt;p>With Docker and k8s you can go from an idea to a production app in hours. Lets take a look how that works in practice. From writing our app to containerizing it to getting it to be available for the entire world to access. Will also look at some sane best practices along the way.&lt;/p>
&lt;h2 id="description">Description&lt;/h2>
&lt;p>Developers want to build applications. So how do we get our app out there in the real world? How do we make sure our app runs everywhere like it runs on our local dev environment?&lt;/p></description></item><item><title>Kubernetes Security Jumpstart</title><link>https://speaking.moficodes.dev/talks/kubernetes-security-jumpstart/</link><pubDate>Sat, 08 Feb 2020 12:50:59 -0400</pubDate><guid>https://speaking.moficodes.dev/talks/kubernetes-security-jumpstart/</guid><description>&lt;h2 id="pitch">Pitch&lt;/h2>
&lt;p>Kubernetes helps with microservice based app problems like scaling, deployment and discovery. But k8s is not a container security tool, and it would be a big mistake to assume that it can defend your apps from security vulnerabilities. We will explore steps we can take towards k8s security.&lt;/p>
&lt;h2 id="description">Description&lt;/h2>
&lt;p>Kubernetes makes it possible to run containerized application at scale. It solves many problems of microservice architecture by abstracting away things like container deployment, container-to-container communication, load balancing. While Kubernetes is great at it many things, it seems to be lacking in terms of security. It has some security features but in most respect it is not production grade security, at least not by default.&lt;/p></description></item><item><title>Knative Serverless Computing on K8s</title><link>https://speaking.moficodes.dev/talks/knative-serverless-computing-on-k8s/</link><pubDate>Sun, 21 Jul 2019 12:50:10 -0400</pubDate><guid>https://speaking.moficodes.dev/talks/knative-serverless-computing-on-k8s/</guid><description>&lt;h2 id="pitch">Pitch&lt;/h2>
&lt;p>Wouldn’t it be nice if as developers we could just focus on our code? That is the promise of serverless. But what if we wanted to leverage our existing kubernetes service and developers? Knative focuses on building these tools and services in a way that elevates the existing Kubernetes experience.&lt;/p>
&lt;h2 id="description">Description&lt;/h2>
&lt;p>Kubernetes excels at container scheduling, and offers useful primitives for automating infrastructure. But we’ve noticed that development teams often struggle when they use vanilla Kubernetes for application deployments. By all means, use Kubernetes to push containers all day long. But if you want to push application code — or a function — Kubernetes on its own isn’t enough.&lt;/p></description></item><item><title>Managing Kubernetes with Istio</title><link>https://speaking.moficodes.dev/talks/managing_k8s_with_istio/</link><pubDate>Mon, 25 Mar 2019 12:21:28 -0400</pubDate><guid>https://speaking.moficodes.dev/talks/managing_k8s_with_istio/</guid><description>&lt;h2 id="pitch">Pitch&lt;/h2>
&lt;p>As monolithic apps are decomposed into microservices, developers have to worry about the challenges in distributed systems like service discovery, load balancing, monitoring, dynamic routing and perhaps most important of all, compliance and security. Istio was created to handle these features.&lt;/p>
&lt;h2 id="description">Description&lt;/h2>
&lt;p>Developers are moving away from large monolithic apps in favor of small, focused microservices that speed up implementation and improve resiliency. Microservices and containers changed application design and deployment patterns, but along with them brought challenges like service discovery, routing, failure handling, security and visibility to microservices.&lt;/p></description></item></channel></rss>